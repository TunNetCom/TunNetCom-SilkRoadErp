@page "/inventaires/add"
@page "/inventaires/edit/{Id:int}"
@using TunNetCom.SilkRoadErp.Sales.Contracts.Inventaire
@using TunNetCom.SilkRoadErp.Sales.Contracts.Products
@using TunNetCom.SilkRoadErp.Sales.Contracts.Sorting
@using TunNetCom.SilkRoadErp.Sales.HttpClients.Services.Inventaire
@using TunNetCom.SilkRoadErp.Sales.HttpClients.Services.Products
@using TunNetCom.SilkRoadErp.Sales.HttpClients.Services.AccountingYear
@using Microsoft.Extensions.Localization
@using TunNetCom.SilkRoadErp.Sales.WebApp.Locales
@using TunNetCom.SilkRoadErp.Sales.WebApp.Components.Shared
@using TunNetCom.SilkRoadErp.Sales.WebApp.Components.Pages.Inventaires
@using TunNetCom.SilkRoadErp.Sales.WebApp.Helpers
@using Radzen
@using Radzen.Blazor
@using BlazorBootstrap
@inject IInventaireApiClient inventaireService
@inject IProductsApiClient productService
@inject IAccountingYearApiClient accountingYearService
@inject IStringLocalizer<SharedResource> Localizer
@inject NavigationManager NavigationManager
@inject ToastService ToastService
@inject DialogService DialogService

<RadzenStack Gap="1.5rem">
    <div>
        <RadzenButton Icon="arrow_back" Text="@Localizer["back"]" Click="@(() => NavigationManager.NavigateTo("/inventaires"))" 
                      ButtonStyle="ButtonStyle.Light" Variant="Variant.Outlined" />
    </div>

    <RadzenCard>
        <RadzenStack Gap="1.5rem">
            <RadzenFormField Text="@($"{Localizer["date_inventaire"]} *")" class="rz-col-12 rz-md-6">
                <RadzenDatePicker @bind-Value="inventaire.DateInventaire" DateFormat="dd/MM/yyyy" ShowTime="false" Style="width: 100%;" />
            </RadzenFormField>

            <RadzenFormField Text="@Localizer["description"]" class="rz-col-12">
                <RadzenTextArea @bind-Value="inventaire.Description" Placeholder="@Localizer["description"]" Rows="3" Style="width: 100%;" />
            </RadzenFormField>

            <div class="rz-col-12">
                <h4>@Localizer["lignes_inventaire"]</h4>
                
                <LineItemsGrid TItem="InventaireLineWrapper"
                               Items="@orders"
                               ItemsChanged="@OnItemsChanged"
                               OnDeleteItem="@DeleteRow"
                               OnProductSelectedCallback="@OnProductSelectedHandler"
                               LoadProducts="@LoadData"
                               GetProductList="@GetCurrentProductList"
                               ProductCount="@count"
                               OnShowPriceHistory="@ShowHistorique"
                               ShowPriceHistoryDialog="true"
                               ShowPrintButton="false"
                               ShowSaveButton="false"
                               ShowSummary="false"
                               ShowVatColumn="false"
                               ShowTtcColumn="false"
                               Localizer="@Localizer"
                               GetProductReference="@(item => item.ProductReference)"
                               SetProductReference="@((item, value) => item.ProductReference = value)"
                               GetProductDescription="@(item => item.Description)"
                               SetProductDescription="@((item, value) => item.Description = value)"
                               ProductTextProperty="ProductReferenceAndDescription"
                               ProductValueProperty="ProductReference"
                               CreateNewItem="@(() => new InventaireLineWrapper { Quantity = 1 })" />
            </div>

            <RadzenStack Orientation="Radzen.Orientation.Horizontal" Gap="1rem" JustifyContent="Radzen.JustifyContent.End" class="rz-col-12">
                <RadzenButton Text="@Localizer["cancel"]" Click="@(() => NavigationManager.NavigateTo("/inventaires"))" 
                              ButtonStyle="ButtonStyle.Light" Variant="Variant.Outlined" />
                <RadzenButton Text="@Localizer["save"]" Click="@SaveInventaire" ButtonStyle="ButtonStyle.Primary" IsBusy="@isSaving" />
            </RadzenStack>
        </RadzenStack>
    </RadzenCard>
</RadzenStack>

@code {
    [Parameter] public int Id { get; set; }
    
    private CreateInventaireRequest inventaire = new();
    private List<InventaireLineWrapper> orders = new();
    private List<InventaireLineWrapper> searchList = new();
    private int count;
    private const int DefaultPageSize = 7;
    private CancellationTokenSource _cancellationTokenSource = new();
    private bool isSaving;
    private int? activeAccountingYearId;

    protected override async Task OnInitializedAsync()
    {
        searchList = new List<InventaireLineWrapper>();
        orders = new List<InventaireLineWrapper>();
        
        await LoadActiveAccountingYear();
        if (Id > 0)
        {
            await LoadInventaire();
        }
        else
        {
            inventaire.DateInventaire = DateTime.Now;
            inventaire.AccountingYearId = activeAccountingYearId ?? 0;
        }
    }

    private async Task LoadActiveAccountingYear()
    {
        try
        {
            var activeYear = await accountingYearService.GetActiveAccountingYearAsync(CancellationToken.None);
            if (activeYear != null)
            {
                activeAccountingYearId = activeYear.Id;
                inventaire.AccountingYearId = activeYear.Id;
            }
        }
        catch (Exception ex)
        {
            _logger?.LogError(ex, "Error loading active accounting year");
        }
    }

    private async Task LoadInventaire()
    {
        try
        {
            var result = await inventaireService.GetByIdAsync(Id, CancellationToken.None);
            if (result.IsT0)
            {
                var fullInventaire = result.AsT0;
                inventaire.DateInventaire = fullInventaire.DateInventaire;
                inventaire.Description = fullInventaire.Description;
                inventaire.AccountingYearId = fullInventaire.AccountingYearId;
                orders = fullInventaire.Lignes.Select(InventaireLineWrapper.FromResponse).ToList();
                UpdateTotals();
            }
        }
        catch (Exception ex)
        {
            _logger?.LogError(ex, "Error loading inventaire");
            ToastService.Notify(new(ToastType.Danger, "Erreur lors du chargement de l'inventaire"));
        }
    }

    async Task LoadData(LoadDataArgs args)
    {
        string _sortProperty = null;
        string _sortOrder = null;
        if (args.Sorts != null && args.Sorts.Any())
        {
            var sort = args.Sorts.First();
            _sortProperty = sort.Property;
            _sortOrder = sort.SortOrder == SortOrder.Ascending ? SortConstants.Ascending : SortConstants.Descending;
        }
        var parameters = new QueryStringParameters
        {
            PageNumber = (args.Skip.Value / DefaultPageSize) + 1,
            PageSize = DefaultPageSize,
            SearchKeyword = args.Filter,
            SortOrder = _sortOrder,
            SortProprety = _sortProperty
        };

        try
        {
            var pagedProducts = await productService.GetPagedAsync(parameters, _cancellationTokenSource.Token);
            searchList = pagedProducts.Items.Select(
                p => new InventaireLineWrapper
                {
                    ProductReference = p.Reference,
                    Description = p.Name,
                    UnitPriceExcludingTax = p.Price,
                    Quantity = 1
                }).ToList();

            count = pagedProducts.TotalCount;
        }
        catch (Exception ex)
        {
            _logger?.LogError(ex, "Error loading products");
            ToastService.Notify(new(ToastType.Danger, "Erreur lors du chargement des produits"));
            searchList = new List<InventaireLineWrapper>();
            count = 0;
        }

        await InvokeAsync(StateHasChanged);
    }

    private List<InventaireLineWrapper> GetCurrentProductList(InventaireLineWrapper currentOrder)
    {
        var resultList = new List<InventaireLineWrapper>();
        
        // If current order has a product reference, ensure it's in the list
        if (!string.IsNullOrEmpty(currentOrder.ProductReference))
        {
            var currentProduct = searchList.FirstOrDefault(p => p.ProductReference == currentOrder.ProductReference);
            
            if (currentProduct != null)
            {
                // Product is already in searchList, add it first
                resultList.Add(currentProduct);
            }
            else
            {
                // Product is not in searchList yet (e.g., when editing existing inventaire)
                // Create a product entry from the current order so it appears in the dropdown
                resultList.Add(new InventaireLineWrapper
                {
                    ProductReference = currentOrder.ProductReference,
                    Description = currentOrder.Description,
                    UnitPriceExcludingTax = currentOrder.UnitPriceExcludingTax,
                    Quantity = 1
                });
            }
            
            // Add all other products from searchList
            resultList.AddRange(searchList.Where(p => p.ProductReference != currentOrder.ProductReference));
        }
        else
        {
            // No current product, return all products from searchList
            resultList.AddRange(searchList);
        }
        
        return resultList;
    }

    private async Task<decimal> GetDernierPrixAchat(string refProduit)
    {
        try
        {
            var result = await inventaireService.GetDernierPrixAchatAsync(refProduit, CancellationToken.None);
            if (result.IsT0)
            {
                return result.AsT0;
            }
        }
        catch (Exception ex)
        {
            _logger?.LogError(ex, "Error getting dernier prix achat");
        }
        return 0;
    }

    async Task OnItemsChanged(List<InventaireLineWrapper> items)
    {
        orders = items;
        UpdateTotals();
        await InvokeAsync(StateHasChanged);
    }

    async Task DeleteRow(InventaireLineWrapper order)
    {
        if (orders.Contains(order))
        {
            orders.Remove(order);
        }
        else if (order.Id > 0)
        {
            var itemToRemove = orders.FirstOrDefault(t => t.Id == order.Id && t.Id > 0);
            if (itemToRemove != null)
            {
                orders.Remove(itemToRemove);
            }
        }

        UpdateTotals();
        await OnItemsChanged(orders);
        StateHasChanged();
    }

    private async Task OnProductSelectedHandler(InventaireLineWrapper order)
    {
        if (!string.IsNullOrEmpty(order.ProductReference))
        {
            // Récupérer le dernier prix d'achat
            var dernierPrixAchat = await GetDernierPrixAchat(order.ProductReference);
            order.DernierPrixAchat = dernierPrixAchat;
            
            // Récupérer le stock calculé pour la quantité théorique
            var stockResult = await productService.GetProductStockAsync(order.ProductReference, CancellationToken.None);
            var quantiteTheorique = stockResult.IsT0 ? stockResult.AsT0.StockCalcule : 0;
            order.QuantiteTheorique = quantiteTheorique;
            
            // Par défaut, utiliser le stock calculé pour la quantité réelle
            // Seulement si la quantité actuelle est 1 (valeur par défaut) ou 0
            // Si l'utilisateur a déjà modifié la quantité, on la préserve
            if (order.Quantity <= 1) // Si c'est la valeur par défaut (1) ou 0
            {
                // Utiliser la quantité théorique si elle est > 0, sinon garder 1
                order.Quantity = quantiteTheorique > 0 ? quantiteTheorique : 1;
            }
            
            // Calculer les totaux
            LineItemCalculator.CalculateTotals(order);
            UpdateTotals();
            await InvokeAsync(StateHasChanged);
        }
    }

    private void UpdateTotals()
    {
        LineItemCalculator.UpdateTotals(orders, out decimal totalHt, out decimal totalVat, out decimal totalTtc);
        // Pour l'inventaire, on n'affiche pas les totaux mais on les calcule quand même pour la cohérence
    }

    private async Task ShowHistorique(string refProduit)
    {
        await DialogService.OpenAsync("Historique Achat/Vente", typeof(HistoriqueAchatVenteModal),
            new Dictionary<string, object> { { "RefProduit", refProduit } },
            new DialogOptions { Width = "900px", Height = "600px" });
    }

    private async Task SaveInventaire()
    {
        isSaving = true;
        try
        {
            inventaire.Lignes = orders.Select(l => l.ToCreateRequest()).ToList();

            if (Id > 0)
            {
                var updateRequest = new UpdateInventaireRequest
                {
                    DateInventaire = inventaire.DateInventaire,
                    Description = inventaire.Description,
                    Lignes = orders.Select(l => l.ToUpdateRequest()).ToList()
                };
                var result = await inventaireService.UpdateAsync(updateRequest, Id, CancellationToken.None);
                if (result.IsT0)
                {
                    ToastService.Notify(new(ToastType.Success, "Inventaire mis à jour avec succès"));
                    NavigationManager.NavigateTo("/inventaires");
                }
                else
                {
                    ToastService.Notify(new(ToastType.Danger, "Erreur lors de la mise à jour"));
                }
            }
            else
            {
                var result = await inventaireService.CreateAsync(inventaire, CancellationToken.None);
                if (result.IsT0)
                {
                    ToastService.Notify(new(ToastType.Success, "Inventaire créé avec succès"));
                    NavigationManager.NavigateTo("/inventaires");
                }
                else
                {
                    ToastService.Notify(new(ToastType.Danger, "Erreur lors de la création"));
                }
            }
        }
        catch (Exception ex)
        {
            _logger?.LogError(ex, "Error saving inventaire");
            ToastService.Notify(new(ToastType.Danger, "Erreur lors de la sauvegarde"));
        }
        finally
        {
            isSaving = false;
        }
    }

    [Inject] private ILogger<AddOrUpdateInventaire>? _logger { get; set; }
}


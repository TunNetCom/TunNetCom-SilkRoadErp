@using TunNetCom.SilkRoadErp.Sales.WebApp.Services
@using Microsoft.Extensions.Logging
@using Microsoft.JSInterop
@inject IAuthService AuthService
@inject NavigationManager Navigation
@inject ILogger<AuthorizeRouteView> Logger
@inject ITokenExpirationNotifier TokenExpirationNotifier
@inject IJSRuntime JSRuntime

@if (IsLoginPage)
{
    <RouteView RouteData="@RouteData" DefaultLayout="@DefaultLayout" />
    <FocusOnNavigate RouteData="@RouteData" Selector="h1" />
}
else if (IsAuthorized)
{
    <RouteView RouteData="@RouteData" DefaultLayout="@DefaultLayout" />
    <FocusOnNavigate RouteData="@RouteData" Selector="h1" />
}
else
{
    <div style="display: flex; justify-content: center; align-items: center; height: 100vh; color: #fff; background: #1a1a1a;">
        <div>Vérification de l'authentification... (@_statusMessage)</div>
    </div>
}


@implements IDisposable

@code {
    [Parameter] public RouteData? RouteData { get; set; }
    [Parameter] public Type? DefaultLayout { get; set; }

    private bool IsAuthorized { get; set; }
    private bool IsLoginPage { get; set; }
    private bool _hasCheckedAuth = false;
    private string _statusMessage = "Initialisation...";

    private string? _lastUri;

    protected override void OnInitialized()
    {
        UpdateLoginPageStatus();
        
        // Subscribe to token expiration events
        TokenExpirationNotifier.OnTokenExpired += HandleTokenExpiredAsync;
    }

    public void Dispose()
    {
        // Unsubscribe from token expiration events
        TokenExpirationNotifier.OnTokenExpired -= HandleTokenExpiredAsync;
    }

    private async Task HandleTokenExpiredAsync()
    {
        Logger.LogWarning("AuthorizeRouteView: Token expired, redirecting to login");
        RedirectToLogin();
        await Task.CompletedTask;
    }

    protected override async Task OnParametersSetAsync()
    {
        // Reset auth check when route changes (e.g., after login)
        var currentUri = Navigation.Uri.ToLowerInvariant();
        var routeChanged = _lastUri != null && _lastUri != currentUri;
        
        // Update login page status first
        var wasLoginPage = IsLoginPage;
        UpdateLoginPageStatus();
        
        if (routeChanged)
        {
            Logger.LogInformation("AuthorizeRouteView: Route changed from {OldUri} to {NewUri}", _lastUri, currentUri);
            _hasCheckedAuth = false;
            // Only reset IsAuthorized if not login page and not already authorized
            if (!IsLoginPage && !IsAuthorized)
            {
                IsAuthorized = false;
            }
        }
        _lastUri = currentUri;
        
        // If route changed and not login page, check auth immediately
        if (routeChanged && !IsLoginPage && !_hasCheckedAuth)
        {
            await CheckAuthenticationAsync();
        }
    }
    
    private async Task CheckAuthenticationAsync()
    {
        if (_hasCheckedAuth)
            return;
            
        _hasCheckedAuth = true;
        _statusMessage = "Chargement du token...";
        StateHasChanged();

        try
        {
            Logger.LogInformation("AuthorizeRouteView: Starting authentication check for new circuit");
            
            // CRITICAL: Always load token from localStorage first
            // This ensures each browser/device uses its OWN localStorage, not a shared server-side cache
            // Each new circuit (browser/phone) will load its own token from its own localStorage
            _statusMessage = "Vérification de l'authentification depuis localStorage...";
            StateHasChanged();
            
            try
            {
                // Force load from localStorage - this is the source of truth for each device
                await AuthService.LoadTokenFromStorageAsync();
                
                Logger.LogInformation("AuthorizeRouteView: Token load completed. IsAuthenticated: {IsAuthenticated}", AuthService.IsAuthenticated);
            }
            catch (Exception ex)
            {
                Logger.LogError(ex, "AuthorizeRouteView: Error loading token from localStorage");
                // Continue to check IsAuthenticated anyway - may be during prerendering
            }
            
            // Now check if authenticated based on what was loaded from THIS device's localStorage
            if (AuthService.IsAuthenticated)
            {
                Logger.LogInformation("AuthorizeRouteView: User authenticated from localStorage, granting access");
                IsAuthorized = true;
                _statusMessage = "Authentifié";
                Logger.LogInformation("AuthorizeRouteView: IsAuthorized set to {IsAuthorized}, calling StateHasChanged", IsAuthorized);
                StateHasChanged();
                // Force a re-render
                await Task.Delay(100);
                StateHasChanged();
                Logger.LogInformation("AuthorizeRouteView: StateHasChanged completed, IsAuthorized: {IsAuthorized}", IsAuthorized);
            }
            else
            {
                // User not authenticated - redirect to login
                // This happens when a new device opens the app without its own login
                Logger.LogWarning("AuthorizeRouteView: No authentication token found in localStorage for this device, redirecting to login");
                _statusMessage = "Non authentifié - redirection...";
                StateHasChanged();
                RedirectToLogin();
            }
        }
        catch (Exception ex)
        {
            // Error during authentication check - redirect to login for safety
            Logger.LogError(ex, "AuthorizeRouteView: Error during authentication check, redirecting to login");
            _statusMessage = "Erreur - redirection...";
            StateHasChanged();
            RedirectToLogin();
        }
    }

    private void UpdateLoginPageStatus()
    {
        // Check if this is the login page - allow access immediately
        var currentUri = Navigation.Uri.ToLowerInvariant();
        var pageType = RouteData?.PageType;
        
        // Only allow login page, block everything else
        var newIsLoginPage = currentUri.EndsWith("/login") || 
                     currentUri.EndsWith("/login/") ||
                     pageType?.Name == "LoginPage" || 
                     pageType?.FullName?.Contains("Login") == true;
        
        IsLoginPage = newIsLoginPage;
        
        // NEVER reset IsAuthorized if it's already true - this causes the render issue
        // Only set to false if we're not on login page AND not already authorized AND haven't checked yet
        if (!IsLoginPage && !IsAuthorized && !_hasCheckedAuth)
        {
            IsAuthorized = false;
        }
    }

    private void RedirectToLogin()
    {
        // Get current URI to use as return URL
        var currentUri = Navigation.Uri;
        var returnUrl = Uri.EscapeDataString(currentUri);
        
        // Don't include returnUrl if we're already on login or if it's the base URL
        var uri = new Uri(currentUri);
        var path = uri.AbsolutePath.ToLowerInvariant();
        
        if (path == "/" || path == "/login" || path == "/login/")
        {
            Logger.LogInformation("AuthorizeRouteView: Redirecting to /login (no return URL)");
            Navigation.NavigateTo("/login", forceLoad: true);
        }
        else
        {
            Logger.LogInformation("AuthorizeRouteView: Redirecting to /login with return URL: {ReturnUrl}", currentUri);
            Navigation.NavigateTo($"/login?returnUrl={returnUrl}", forceLoad: true);
        }
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        // Always allow login page without any async checks
        if (IsLoginPage)
        {
            _hasCheckedAuth = false; // Reset for next time
            _statusMessage = "Page de login";
            return;
        }

        // Only check on first render if not already checked
        if (firstRender && !_hasCheckedAuth)
        {
            await CheckAuthenticationAsync();
        }
    }
}


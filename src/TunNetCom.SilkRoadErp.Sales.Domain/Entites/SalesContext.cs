// <auto-generated> This file has been auto generated by EF Core Power Tools. </auto-generated>
using Microsoft.EntityFrameworkCore;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Linq.Expressions;
using System.Reflection;
using TunNetCom.SilkRoadErp.Sales.Domain.Entites.Configurations;
using TunNetCom.SilkRoadErp.Sales.Domain.Views;
#nullable enable

namespace TunNetCom.SilkRoadErp.Sales.Domain.Entites;

public partial class SalesContext : DbContext
{
    // Variable AsyncLocal pour stocker l'ID de l'exercice actif de manière thread-safe avec async/await
    // Cette valeur sera mise à jour par le middleware au début de chaque requête HTTP
    private static readonly AsyncLocal<int?> _activeAccountingYearId = new();

    public static void SetActiveAccountingYearId(int? yearId)
    {
        _activeAccountingYearId.Value = yearId;
    }

    public SalesContext(DbContextOptions<SalesContext> options)
        : base(options)
    {
    }

    public virtual DbSet<AvoirFinancierFournisseurs> AvoirFinancierFournisseurs { get; set; }

    public virtual DbSet<AvoirFournisseur> AvoirFournisseur { get; set; }

    public virtual DbSet<Avoirs> Avoirs { get; set; }

    public virtual DbSet<AccountingYear> AccountingYear { get; set; }

    public virtual DbSet<BonDeLivraison> BonDeLivraison { get; set; }

    public virtual DbSet<BonDeReception> BonDeReception { get; set; }

    public virtual DbSet<Client> Client { get; set; }

    public virtual DbSet<Commandes> Commandes { get; set; }

    public virtual DbSet<Devis> Devis { get; set; }

    public virtual DbSet<EcheanceDesFournisseurs> EcheanceDesFournisseurs { get; set; }

    public virtual DbSet<Facture> Facture { get; set; }

    public virtual DbSet<FactureAvoirClient> FactureAvoirClient { get; set; }

    public virtual DbSet<FactureAvoirFournisseur> FactureAvoirFournisseur { get; set; }

    public virtual DbSet<FactureFournisseur> FactureFournisseur { get; set; }

    public virtual DbSet<Fournisseur> Fournisseur { get; set; }

    public virtual DbSet<LigneAvoirFournisseur> LigneAvoirFournisseur { get; set; }

    public virtual DbSet<LigneAvoirs> LigneAvoirs { get; set; }

    public virtual DbSet<LigneBl> LigneBl { get; set; }

    public virtual DbSet<LigneBonReception> LigneBonReception { get; set; }

    public virtual DbSet<LigneCommandes> LigneCommandes { get; set; }

    public virtual DbSet<LigneDevis> LigneDevis { get; set; }

    public virtual DbSet<Produit> Produit { get; set; }

    public virtual DbSet<Systeme> Systeme { get; set; }

    public virtual DbSet<Transaction> Transaction { get; set; }

    public virtual DbSet<ReceiptNoteView> ReceiptNoteView { get; set; }

    public virtual DbSet<ProviderInvoiceView> ProviderInvoiceView { get; set; }

    public virtual DbSet<Banque> Banque { get; set; }

    public virtual DbSet<PaiementClient> PaiementClient { get; set; }

    public virtual DbSet<PaiementFournisseur> PaiementFournisseur { get; set; }

    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        modelBuilder.ApplyConfigurationsFromAssembly(typeof(FactureConfiguration).Assembly);

        // Configurer les Global Query Filters pour toutes les entités qui implémentent IAccountingYearEntity
        ConfigureAccountingYearFilters(modelBuilder);

        OnModelCreatingPartial(modelBuilder);
    }

    private void ConfigureAccountingYearFilters(ModelBuilder modelBuilder)
    {
        // Trouver toutes les entités qui implémentent IAccountingYearEntity
        var entityTypes = modelBuilder.Model.GetEntityTypes()
            .Where(et => typeof(IAccountingYearEntity).IsAssignableFrom(et.ClrType))
            .ToList();

        foreach (var entityType in entityTypes)
        {
            var clrType = entityType.ClrType;
            var parameter = Expression.Parameter(clrType, "e");
            var property = Expression.Property(parameter, nameof(IAccountingYearEntity.AccountingYearId));

            // Utiliser une variable capturée qui sera résolue au moment de l'exécution
            // On crée une expression qui compare AccountingYearId avec une valeur qui sera résolue dynamiquement
            // Pour cela, on utilise une méthode qui sera appelée via un interceptor ou un middleware
            // Pour l'instant, on crée un filtre qui sera évalué à chaque requête via le service
            
            // Créer une expression qui utilise le service pour obtenir l'exercice actif
            // On utilise une closure pour capturer le contexte
            var filterExpression = CreateAccountingYearFilterExpression(clrType);
            
            // Appliquer le filtre
            modelBuilder.Entity(clrType).HasQueryFilter(filterExpression);
        }
    }

    private LambdaExpression CreateAccountingYearFilterExpression(Type entityType)
    {
        var parameter = Expression.Parameter(entityType, "e");
        var property = Expression.Property(parameter, nameof(IAccountingYearEntity.AccountingYearId));
        
        // Utiliser la variable statique thread-safe pour obtenir l'ID de l'exercice actif
        // Cette valeur sera mise à jour par le middleware au début de chaque requête HTTP
        var getActiveYearIdMethod = typeof(SalesContext).GetMethod(
            nameof(GetActiveAccountingYearId),
            BindingFlags.NonPublic | BindingFlags.Static)!;
        
        var methodCall = Expression.Call(getActiveYearIdMethod);
        
        // Si la valeur est null, on retourne -1 pour que la comparaison échoue
        var nullCheck = Expression.Condition(
            Expression.Equal(methodCall, Expression.Constant(null, typeof(int?))),
            Expression.Constant(-1),
            Expression.Property(methodCall, "Value"));
        
        var equals = Expression.Equal(property, nullCheck);
        return Expression.Lambda(equals, parameter);
    }

    private static int? GetActiveAccountingYearId()
    {
        return _activeAccountingYearId.Value;
    }

    partial void OnModelCreatingPartial(ModelBuilder modelBuilder);
}
